<div class="html">
  <div class="body">
<div id="rendered-md"><p>The main data structures are:</p>
<ul>
<li>list</li>
<li>tuples</li>
<li>dictionaries</li>
<li>sets</li>
</ul>
<h2 id="lists">Lists</h2>
<ul>
<li>It is an object in python; used to store an indexed list of items. It is created using square brackets ([]) with commas separating them.</li>
</ul>
<p>Syntax:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="python" data-joplin-source-open="```python&#10;" data-joplin-source-close="&#10;```">var = [&quot;one&quot;, &quot;two&quot;]</pre><pre class="hljs"><code>var = [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>]</code></pre></div>
<ul>
<li>To access the values, use index starting from 0.</li>
<li>The <code class="inline-code">in</code> and <code class="inline-code">not in</code> operators checks if items are in the list.</li>
</ul>
<h5 id="common-list-functions">Common List Functions:</h5>
<ul>
<li><code class="inline-code">append</code> method addds an item to an existing list at the end.</li>
</ul>
<p>E.g.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="python" data-joplin-source-open="```python&#10;" data-joplin-source-close="&#10;```">nums = [1, 2, 3]
nums.append(4)
nums = [1, 2, 3, 4]</pre><pre class="hljs"><code>nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
nums.append(<span class="hljs-number">4</span>)
nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</code></pre></div>
<ul>
<li>To get the number of items in a list, use <code class="inline-code">len</code> function.<br>
E.g. <code class="inline-code">len(list)</code></li>
<li><code class="inline-code">insert</code> method allows you to add an item to any position in a list.<br>
Syntax: <code class="inline-code">list.insert(index, value)</code></li>
<li><code class="inline-code">index</code> method finds the first occurence of an item in a list and returns its index.<br>
Syntax: <code class="inline-code">list.index(obj_value)</code></li>
<li><code class="inline-code">max</code> function returns the list item with the maximum value.</li>
<li><code class="inline-code">min</code> function returns the list item with the minimum value.</li>
<li><code class="inline-code">list.count(obj)</code> returns the count of how many times an item occurs in a list.</li>
<li><code class="inline-code">list.remove(obj)</code> removes an object from a list.</li>
<li><code class="inline-code">list.reverse()</code> function reverses objects in a list.</li>
</ul>
<h5 id="list-comprehensions">List Comprehensions:</h5>
<p>It is a useful way of quickly creating lists whose contents obey a simple rule.<br>
E.g.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="python" data-joplin-source-open="```python&#10;" data-joplin-source-close="&#10;```">cubes = [i**3 for i in range(5)]
    #output: [0, 1, 8, 27, 64]</pre><pre class="hljs"><code>cubes = [i**<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]
    <span class="hljs-comment">#output: [0, 1, 8, 27, 64]</span></code></pre></div>
<h5 id="list-slices">List Slices:</h5>
<p>E.g.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="python" data-joplin-source-open="```python&#10;" data-joplin-source-close="&#10;```">sq = [0, 1, 2, 3, 4, 5]
print(sq[1:5])
#output: [1, 2, 3, 4]</pre><pre class="hljs"><code>sq = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
print(sq[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>])
<span class="hljs-comment">#output: [1, 2, 3, 4]</span></code></pre></div>
<ul>
<li><code class="inline-code">[1:5]</code> starts from index 1 and stops at index 5(with index 5â€™s value excluded).</li>
<li>If the first number of a slice is omitted, it is taken from the start of the list. E.g. <code class="inline-code">[:5]</code></li>
<li>If the second number of a slice is omitted, it is taken to the end of the list. E.g. <code class="inline-code">[1:]</code></li>
<li>It can be applied to turples.</li>
<li>There is a third number for step. E.g. <code class="inline-code">[2:3:3]</code></li>
<li>When negative values are used in slices, they count from the end of the list.</li>
</ul>
<h2 id="turples">Turples</h2>
<ul>
<li>They are very similar to lists except that they cannot be changed.<br>
Syntax:</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="python" data-joplin-source-open="```python&#10;" data-joplin-source-close="&#10;```">var = (val, val, val)
    #Or
var = val, val, val</pre><pre class="hljs"><code>var = (val, val, val)
    <span class="hljs-comment">#Or</span>
var = val, val, val</code></pre></div>
<ul>
<li>Turples are faster than lists.</li>
</ul>
<h2 id="dictionaries">Dictionaries</h2>
<p>They are used to map arbituary keys to values.<br>
Syntax:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="python" data-joplin-source-open="```python&#10;" data-joplin-source-close="&#10;```">var = {val: val1}
    #To access the value
var[val]
    #Adding new values
var[key] = value</pre><pre class="hljs"><code>var = {val: val1}
    <span class="hljs-comment">#To access the value</span>
var[val]
    <span class="hljs-comment">#Adding new values</span>
var[key] = value</code></pre></div>
<h2 id="sets">Sets</h2>
<ul>
<li>They are similar to lists and dictionaries but are unordered, so they cannot be indexed.<br>
Syntax:</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="python" data-joplin-source-open="```python&#10;" data-joplin-source-close="&#10;```">var = {val1, val2, val3}
    #Or
var = set([val1, val2, val3])
    #For empty set
var = set()</pre><pre class="hljs"><code>var = {val1, val2, val3}
    <span class="hljs-comment">#Or</span>
var = set([val1, val2, val3])
    <span class="hljs-comment">#For empty set</span>
var = set()</code></pre></div>
<ul>
<li>They cannot contain duplicate elements.</li>
<li>To add new value, use the <code class="inline-code">add(val)</code> method.</li>
<li><code class="inline-code">remove(val)</code> method removes specific elements from a set.</li>
<li><code class="inline-code">pop()</code> method removes the first element.</li>
</ul>
<h5 id="set-operators">Set Operators</h5>
<div>
  <div class="bd-example">
    <table class="table table-striped">
      <thead>
        <tr>
          <th scope="col">Operator</th>
          <th scope="col">Description</th>
        </tr>
      </thead>
      <tbody>
        {% for ops in sets %}
        <tr>
          <td>{{ ops.sign }}</td>
          <td>{{ ops.description }}</td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
<h2 id="note-when-to-use-the-different-types-of-data-structures">Note: When to use the different types of data structures</h2>
<hr>
<h5 id="when-to-use-lists">When To Use Lists:</h5>
<ul>
<li>When you have a collection of data that does not need random access.</li>
<li>When you need a simple iterable collection that is modified frequently.</li>
</ul>
<h5 id="when-to-use-dictionaries">When to use Dictionaries:</h5>
<ul>
<li>When you need a logical association between a key value pair.</li>
<li>When you need fast lookup on your data based on a custom key.</li>
<li>When data is constantly modified since they are mutable.</li>
</ul>
<h5 id="when-to-use-turples">When to use Turples:</h5>
<ul>
<li>When your data cannot change</li>
</ul>
<h5 id="when-to-use-sets">When to use Sets:</h5>
<ul>
<li>When you need uniqueness for data elements.</li>
</ul>
</div></div>
  </div>
</div>